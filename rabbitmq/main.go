package main

//func failOnError(err error, msg string) {
//	if err != nil {
//		log.Fatalf("%s: %s", msg, err)
//	}
//}
//
//func main(){
//	// 1. 尝试连接RabbitMQ，建立连接
//	// 该连接抽象了套接字连接，并为我们处理协议版本协商和认证等。
//	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
//	failOnError(err, "Failed to connect to RabbitMQ")
//	defer conn.Close()
//
//	// 2. 接下来，我们创建一个通道，大多数API都是用过该通道操作的。
//	ch, err := conn.Channel()
//	failOnError(err, "Failed to open a channel")
//	defer ch.Close()
//
//	// 3. 声明消息要发送到的队列,声明队列是幂等的,当队列不存在时才创建
//	q, err := ch.QueueDeclare(
//		"hello", // name
//		false,   // durable
//		false,   // delete when unused
//		false,   // exclusive
//		false,   // no-wait
//		nil,     // arguments
//	)
//	failOnError(err, "Failed to declare a queue")
//
//	body := "Hello World!"
//	// 4.将消息发布到声明的队列
//	err = ch.Publish(
//		"",     // exchange
//		q.Name, // routing key
//		false,  // mandatory
//		false,  // immediate
//		amqp.Publishing {
//			ContentType: "text/plain",
//			Body:        []byte(body),
//		})
//	failOnError(err, "Failed to publish a message")
//}
